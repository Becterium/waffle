### 接口Req && Res

1. 所有结构定义的 **Request和Respond** 数据的结构在 api/***/service/v1 中的 .proto 文件可查看

2. 在 biz 层定义好 数据库 对应的 操作对象 

3. 对于数据的处理 ：~~~~在service层，对Request进行拆解，将 元数据 包装进 biz层 对应的数据库操作对~~
     ~~象，返回也是用 biz层 对应的数据库操作对象 返回，返回的数据由 service层 拆解，包装进Respond（这~~
       ~~样好像牺牲了很多灵活性，而且对于SQL操作这个流程，有很多额外的内存开销，比如SQL只需要一个数~~
       ~~据，你的request中也只有一个数据，但是你还要封装一次拆解一次，有很多额外开销呢。但是好处就是代~~
       ~~码好看，格式统一吧。建议对于很小的元数据，直接打到data层进行SQL操作，中庸点）~~

     api层定义了请求和响应的数据结构，在service层接收后，直接传到biz层（减少多个变量导致内存消耗），

     biz层要定义好repo的interface接口（repo由data层实现，实现的是实际数据操作的方法）,~~data层定义与数~~

     ~~据库交互的结构体和方法，biz层的逻辑function可以直接引用data层定义的结构体去进行数据转换~~,data层

     定义与数据库交互的结构体，如果让biz层直接引用data层的数据结构,会引发biz层和data层的相互调用问

     题，所以只能把与数据库交互的数据结构体放到data层，然后biz层写一个简略的结构体，打到data层进行转

     换

     

4. 对于错误的处理，错误产生源多半在data层，由data层产生的错误直接传到service层进行处理，有api层定

     义的*error.proto*，分析来自底层传上来的错误，进行处理，处理后用error.proto定义的错误返回响应

5. 在wire依赖线路中，由于DDD的关系，层级之间的数据结构的依赖一般不用 ***** 直接指针引用，而是直接复制

     （ 例：UserUseCase{ repo UserRepo, log *log.logger } ）在我看来由于只是短暂的处理请求，不存在多

     层的依赖（ 日志是多层都要依赖 ），所以不需要，用完就由垃圾桶清理

​		tip:

```sh
需要改变传入函数的参数值时，使用指针。
需要避免大对象的拷贝时，使用指针。
实现接口且需要改变结构体状态时，使用指针。
希望表达“可选”或“空”值时，使用指针。
```

6. api 结构体命名规范：操作 + 对象 + req/reply
